# ProgPoW exploit

describe ASIC friendly computation method of ProgPoW

## Table of Contents

- [Design flaw](#flaw)
- [Usage](#usage)
- [Test vectors](#test-vectors)
- [Optimizations](#optimizations)
- [Maintainer](#maintainer)
- [License](#license)

## Design flaw

ProgPow has a design flaw:
> 64 bit `seed` is too small, 

This allows ASICs can modify comuptation order so that ASICs need not access memory.

## Preliminary

Thanks chfast for providing a readable implementation!

ProgPoW hash function is defined as:
```C++
result hash(const epoch_context& context, int block_number, const hash256& header_hash,
    uint64_t nonce) noexcept
{
    const uint64_t seed = keccak_progpow_64(header_hash, nonce);
    const hash256 mix_hash = hash_mix(context, block_number, seed, calculate_dataset_item_2048);
    const hash256 final_hash = keccak_progpow_256(header_hash, seed, mix_hash);
    return {final_hash, mix_hash};
}
```

## ASIC friendly Computation 

Suppose a block header `block_header` and a block number `block_number` are given.

Then, run 3 steps below:
1. fix a `seed` to any 64 bit value and compute `mix_hash = hash_mix(block_number, seed)`.
2. search `extra_nonce` so that `header_hash` meets diffculity condition.
3. search `nonce` so that `keccak_progpow_64(header_hash, nonce) == seed`.

In first step, a `mix_hash` is computed for a fixed `seed` and `block_number`.
Because `mix_hash` is designed to be a function of `seed` and `block_number`, we get a valid triple `(seed, mix_hash, block_number)`.
Now, our goal is find a `header_hash` and a `nonce` satisfy two conditions:

* (A) `keccak_progpow_64(header_hash, nonce) == seed`
* (B) `keccak_progpow_256(header_hash, seed, mix_hash) <= boundary`

Remember we can generate any number of header hash by modifying extra nonce (use ExtraData in Ethereum).
Thus, condition (B) is easily acomplished by step 2.
Now, we have a fixed `(header_hash, seed, mix_hash, block_number)` but `nonce` is free yet.

Finally, step 3 scans `nonce` for condition (A).
Because `seed` has only 64 bit length, condition (A) provides only 64 bit security and step 3 can be executed by ASICs.

## Computation cost

There are four functions `kecchak_1600`, `keccak_progpow_64`, `hash_mix` and `keccak_progpow_256`.
Computation cost can be evaluated by counting these function calls needed before getting an answer.  This depends on network difficulty `D`.

|                     |avg # of calls in normal|avg # of calls in ASIC|
|---------------------|---|----|
|`kecchak_1600`       |  1|   D|
|`keccak_progpow_64`  |  D|2^64|
|`hash_mix`           |  D|   1|
|`keccak_progpow_256` |  D|   D|

In normal hash computation, one `kecchak_1600` call is needed to compute `header_hash` and other functions are sequencially called for each `nonce` value.

In ASIC hash computation, one `hash_mix` call is needed in step 1, `kecchak_1600` and `keccak_progpow_256` are called in step 2, and `keccak_progpow_64` is called in step 3.

Since `hash_mix` is called only once in our ASIC computation, we can use host CPU to compute `hash_mix`.
Other functions are all keccak hash function, need no memory, and are easily computed on ASICs.

We need compare `D` and `2^64` in `keccak_progpow_64` row.
Simply, larger `D` makes ASIC more profitable.
Estimating profitable threshold is hard, but I think current difficulty (> 2^50) is large enough.

## Demo

Demo is in this repository.

```
$ git clone https://github.com/kik/progpow-exploit.git
$ cd progpow-exploit
$ mkdir build
$ cd build
$ cmake ..
$ make
$ ./test/ethash-test --gtest_filter=asic.search
```

In this demo, `seed` is truncated to 24 bit width to run on CPU.
See [code](lib/ethash/progpow.cpp#L287).

Test code is simple [test](test/unittests/test_asic.cpp).

`search_asic` is defined here [code](lib/ethash/progpow.cpp#L362).

### normal ProgPoW
```C++
header_hash = BH.hash();
for (nounce : nounces) {
    uint64_t seed = keccak_progpow_64(header_hash, nonce);
    const hash256 mix_hash = hash_mix(bn, seed);
    const hash256 final_hash = keccak_progpow_256(header_hash, seed, mix_hash);
    if (is_less_or_equal(r.final_hash, boundary)) {
        return {r, nonce};
    }
}
```

### ASIC friendly ProgPoW

1. fix `seed` to any 64bit value and compute `hash_mix()`.
2. scan `extra_nonce` to search `header_hash` with diffculty condition passed.
3. scan `nonce` to search `keccak_progpow_64(header_hash, nonce) == seed`.

```C++
// 1. fix `seed` to any 64bit value and compute `hash_mix()`.
const uint64_t seed = uint64_t(0);
const hash256 mix_hash = hash_mix(bn, seed);
// 2. scan `extra_nonce` to search
const uint64_t end_extra_nonce = start_extra_nonce + extra_iterations;
for (uint64_t extra_nonce = start_extra_nonce; extra_nonce < end_extra_nonce; ++extra_nonce)
{
    // compute header_hash
    const block_header new_header = { header.parent, extra_nonce };
    const hash256 header_hash = ethash_keccak256((const uint8_t *)&new_header, sizeof new_header);
    // compute final_hash
    const hash256 final_hash = keccak_progpow_256(header_hash, seed, mix_hash);
    if (is_less_or_equal(final_hash, boundary))
    {
        // `header_hash` passed diffculty condition.

        // 3. scan `nonce` to search `keccak_progpow_64(header_hash, nonce) == seed`.
        const uint64_t end_nonce = start_nonce + iterations;
        for (uint64_t nonce = start_nonce; nonce < end_nonce; ++nonce)
        {
            const uint64_t result_seed = keccak_progpow_64(header_hash, nonce);
            if (seed == result_seed)
                // got it!
                return {{final_hash, mix_hash}, nonce, extra_nonce};
        }
    }
}
```
## Install

Build from source using CMake.

```sh
mkdir build
cd build
cmake ..
cmake --build .
```

## Usage

See [ethash.hpp] for list of exported function and documentation.


## Test vectors

- [ProgPoW test vectors](test/unittests/progpow_test_vectors.hpp)


## Optimizations

This section decscribes the optimizations, modification and tweaks applied
in this library in relation to [Ethash reference implementation].

The library contains a set of micro-benchmarks. Build and run `bench` tool.

### Seed hash is computed on the fly.
   
Seed hash is sequence of keccak256 hashes applied the epoch number of times.
Time needed to compute seed hash is negligible comparing to time needed to build
light cache. Computing seed hash for epoch 10000 takes ~ 5 ms, building light
cache for epoch 1 takes ~ 500 ms.

### Dataset size is computed on the fly

Computing the size of full dataset and light cache requires finding the largest
prime number given an upper bound. For similar reasons as with seed hash, this
is computed on the fly. The procedure used is quite naive and forks well only
up to 40-bit number, so some additional improvement can be done in future.
   
    
## Maintainer

PaweÅ‚ Bylica [@chfast]

## License

Licensed under the [Apache License, Version 2.0].


[@chfast]: https://github.com/chfast
[Apache License, Version 2.0]: LICENSE
[ethash.hpp]: include/ethash/ethash.hpp
[Ethash reference implementation]: https://github.com/ethereum/wiki/wiki/Ethash
